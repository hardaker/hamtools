#!/usr/bin/perl

use Hamlib;
use Getopt::GUI::Long;
use strict;
use Time::HiRes qw(usleep gettimeofday tv_interval);
use Data::Dumper;
use IO::File;

use lib ('/home/hardaker/docs/ham/hamtools');
use MyScanner;
use MyApp;

my %opts = (
	    P => '/dev/ttyS0',
	    M => '122',
	    S => '38400',

	    s => '14.150',
	    e => '14.350',
	    i => '.0001',
	    u => '.1',
	    samples => '1',
	    c => ($ENV{'HOME'} . "/.cqrc"),
	    l => -12,

	    time => 10,
	    hangtime => 3,
	   );

Getopt::GUI::Long::Configure(qw(display_help no_ignore_case capture_output));
GetOptions(\%opts,
	   ["GUI:separator",     "Scanning Options:"],
	   ["s|start-frequency=s", "Starting Frequency"],
	   ["e|end-frequency=s",   "Ending Frequency"],
	   ["i|sample-interval=s", "Steps between frequencies"],
	   ["samples=s",           "Samples to take"],
	   ["l|minimum-level=s",   "Minimum signal level to be reported"],

	   ["state=s",             "store state in file"],
           ["load=s",              "load state from file; don't rescan"],

	   ["scan=s",              "Scan this definition set"],
	   ["u|usleep=s",          "time between sleeps"],
	   ["hangtime=s",          "time in seconds to hang on an empty channel after traffic stops"],

	   ["GUI:separator",   "Hamlib Controls:"],
	   ["P|port=s",        "Port to use (/dev/ttyS0)"],
	   ["M|model=s",         "Rig model (122)"],
	   ["S|speed=s",       "serial speed"],

	   ["GUI:separator",   "Setup options:"],
	   ["c|config",        "Config file to load"],
	   ["test",            "Test retunning speed of the receiver"],
	   ["test-freqs=s",    "Set the starting and various frequencies to jump to"],
	   ["v|verbose",       "Verbose mode"],

	   ["GUI:separator",   "Output Controls:"],
	   ["g|gnuplot=s",     "gnuplot data file"],
	   ["G|graphic=s",     "png data output"],
	   ["w",                "create an output window"],

	   ["nogui", "Don't show the gui"],
	  ) || die "bad arguments";

$| = 1;

Hamlib::rig_set_debug(1);
my $rig = new Hamlib::Rig($opts{'M'});
$rig->set_conf("rig_pathname", $opts{'P'});
$rig->set_conf("serial_speed",$opts{'S'});
$rig->open();
my $freq = $rig->get_freq();
my %data;

my %config;
my %groups;
# scanning vars
my ($currentchannel, $currentstart, $currentlivetime, @toscan);

#$rig->set_mode($Hamlib::RIG_MODE_USB, $Hamlib::RIG_PASSBAND_NORMAL);
#$rig->set_freq($opts{'s'} * 1000000);

read_config($opts{'c'});

if ($opts{'test'}) {
    my $startfreq = 14.250;
    my @jumpvalues = qw(.001 .00001 .25);
    if ($opts{'test-freqs'}) {
	($startfreq, @jumpvalues) = split(/,/,$opts{'test-freqs'});
    }

    $rig->set_freq($startfreq * 1000000);
    sleep(1);

    my $max = 0;
    foreach my $delta (@jumpvalues) {
	my $value = 0;
	Verbose("setting to $startfreq\n");
	$rig->set_freq($startfreq * 1000000);
	$value = $rig->get_level_i($Hamlib::RIG_LEVEL_STRENGTH);
	Verbose("  immediate value: $value\n");
	usleep(.5 * 1000000);
	$value = $rig->get_level_i($Hamlib::RIG_LEVEL_STRENGTH);
	Verbose("  initial value: $value\n");
	$value = 0;
	Verbose("  setting to " . ($startfreq+$delta) . "\n");
	$rig->set_freq(($startfreq+$delta) * 1000000);
	my $count = 0;
	$value = -54;
	my $prevvalue;
	my $startedat = [gettimeofday];
	while ($value < -32) {  # kinda arbitrary
	    $prevvalue = $value;
	    $value = $rig->get_level_i($Hamlib::RIG_LEVEL_STRENGTH);
	    $count++;
	    usleep(.00005 * 1000000);
	}
	Verbose("  final value: $value (was $value; $count polls to change)\n");
	my $diff = tv_interval($startedat, [gettimeofday]);
	Verbose("  $delta change => $diff\n");
	$max = ($max > $diff) ? $max : $diff;
    }
    printf("\nRecommended -u setting: %f (which is 5 * $max)\n",$max*5);

    exit;
}

sub find_group_members {
    my @names = @_;
    my @ret;
    foreach my $name (@names) {
	if (exists($groups{uc($name)})) {
	    push @ret, find_group_members(@{$groups{uc($name)}})
	} else {
	    die "ack: no such channel: $name" if (!exists($config{$name}));
	    push @ret, $name;
	}
    }
    return @ret;
}

#
# Load previous state
#
if ($opts{'load'}) {
    my $var = do "$opts{'load'}";
    %data = %$var;

#
# Scanning
#
} elsif ($opts{'scan'}) {
    @toscan = keys(%config);
    if ($opts{'scan'} ne 1) {
	@toscan = find_group_members(split(/,\s*/,uc($opts{'scan'})));
	Verbose("scan list: ", join(", ", @toscan),"\n");
    }

    while (1) {

	next_scan();
	
	if ($opts{'w'}) {
	    $MyApp::type = 'scan';
	    my $app = MyApp->new(); # create
	    $app->MainLoop();	# go
	}

	# XXX: configurable sleep needed.
	if ($currentchannel) {
	    sleep(1);
	} else {
	    usleep($opts{'i'} * 1000000);
	}
    }
} else {
    for (my $freq = $opts{'s'}; $freq <= $opts{'e'}; $freq += $opts{'i'}) {
	$rig->set_freq($freq * 1000000);

	my $value;
	my $count = 0;
	while ($count < $opts{'samples'}) {
	    usleep($opts{'u'} * 1000000);
	    $value += $rig->get_level_i($Hamlib::RIG_LEVEL_STRENGTH);
	    $count++;
	}
	$data{$freq} = $value / $count;
    }
}

    if ($opts{'state'}) {
	open(O,">$opts{'state'}");
	print O Dumper(\%data);
	close(O);
    }

my @keys = sort keys(%data);
my @sortedbylevel = sort { $data{$b} <=> $data{$a} } @keys;
my $leveltobeat = $opts{'l'} || $data{$sortedbylevel[int($#sortedbylevel/2)]};

my $ingood = 0;
my $startgood = 0;
my $level;
Verbose("finding signals above:  $leveltobeat\n");
for (my $i = 0; $i < $#keys; $i++) {
    if (!$ingood && $data{$keys[$i]} > $leveltobeat) {
	# starting a signal
	$ingood = 1;
	Verbose("good starting at: $keys[$i]\n");
	$startgood = $keys[$i];
	$level = $data{$keys[$i]};
    } elsif ($ingood && $data{$keys[$i]} <= $leveltobeat) {
	# falling out
	$ingood = 0;
	Verbose("	    end: $keys[$i]\n");
	printf ("	   diff: %-4.4f\n", ($keys[$i] - $startgood));
        Verbose("   level: $level\n");
	Verbose("	 center: " . ($startgood + ($keys[$i] - $startgood)/2) . "\n");
    } elsif ($ingood) {
	$level = $data{$keys[$i]} if ($level < $data{$keys[$i]});
    }
}

if ($opts{'g'}) {
    open(G, ">$opts{'g'}");
    foreach my $key (@keys) {
	print G "$key  $data{$key}\n";
    }
    close(G);
}

if ($opts{'G'}) {
    my $im = create_freq_graph();
    open(G,">$opts{'G'}");
    binmode G;
    print G $im->png;
}

if ($opts{'w'}) {
    my $im = create_freq_graph();
    open(G,">/tmp/cq.png");
    binmode G;
    print G $im->png;
    close(G);
}

sub create_freq_graph {
    use GD;
    my $height = 100;
    my $im = new GD::Image($#keys,$height);
    my $fill = $im->colorAllocate(0,0,255);
    my $white = $im->colorAllocate(255,255,255);
    $im->fill(1,1,$white);

    my $count = 0;
    foreach my $key (@keys) {
	$im->rectangle($count, $height - ($data{$key} + 50), $count+1, $height, $fill);
	$count++;
    }
    return $im;
}

#
# Wx widget support
#
if ($opts{'w'}) {
    my $app = MyApp->new();	# create
    $app->MainLoop();		# go
}

sub next_scan {
    my $time = time();
    my $next = "";
    my $currentlevel;

    die "no scan list available!" if ($#toscan == -1);

    #
    # see if the current channel is still active (or else forget it
    #
    if ($currentchannel) {
	# see if current is active
	$currentlevel = $rig->get_level_i($Hamlib::RIG_LEVEL_STRENGTH);

	# completely fall off the current channel if it's been
	# inactive for longer than the specified hangtime.
	if ($currentlevel < $opts{'l'} &&
	    $currentlivetime +
	    ($config{$currentchannel}{'hangtime'} || $opts{'hangtime'})
	    < $time) {
	    Verbose(sprintf("current: -- $currentchannel ended: %ds --\n",
			    $currentlivetime-$currentstart));
	    $currentchannel = '';
	}

	if ($currentlevel > $opts{'l'}) {
	    $currentlivetime = $time;
	}
    }

    #
    # find the next channel to look for.
    #
    foreach my $key (@toscan) {

	# if it has been long enough based on config, check it
	if ($config{$key}{'lastchecked'} < $time + ($config{$key}{'checkevery'} || $opts{'time'})) {

	    # if disabled, forget it
	    next if ($config{$key}{'enabled'} eq 'false');

	    # if the current channel is active and is a higher
	    # priority, then skip this one.
	    next if ($currentchannel &&
		     $config{$key}{'priority'} <=
		     $config{$currentchannel}{'priority'});

	    # if we've checked it recently enough, don't do again
	    # (assuming we're listening to something, otherwise
	    # check anyway even though it's early).
	    next if (($config{$key}{'lastchecked'} +
		      ($config{$next}{'checkevery'} || $opts{'time'})
		      > $time) && $currentchannel);

	    # ok, then we should definitely search it.  But we
	    # need to pick the best one, so see if we have another
	    # one that needs to be checked first.
	    # XXX: optionally use priorities instead of time for sorting?
	    if (!$next) {
		$next = $key;
	    } elsif ($config{$next}{'lastchecked'}
		     + ($config{$next}{'checkevery'} || $opts{'time'}) >
		     $config{$key}{'lastchecked'}
		     + ($config{$key}{'checkevery'} || $opts{'time'})) {
		$next = $key;
	    }
	}
    }

    #
    # now that we've found one to check, see if we should switch to it
    #
    if ($next) {
	my $frequency;

	# normal channel or frequency range?
	if ($config{$next}{'endfrequency'}) {
	    # we're scanning a whole range; take the next step forward
	    if ($config{$next}{'currentfrequency'}) {
		$frequency = $config{$next}{'currentfrequency'} +
		  $config{$next}{'interval'} || $opts{'i'};
		if ($frequency > $config{$next}{'endfrequency'}) {
		    $frequency = $config{$next}{'startfrequency'};
		}
	    } else {
		$frequency = $config{$next}{'startfrequency'};
	    }
	    $config{$next}{'currentfrequency'} = $frequency;
	} else {
	    # just a single channel
	    $frequency = $config{$next}{'frequency'};
	}

	# what to check next?

	# change the frequency and potentially the mode
	$rig->set_freq($frequency * 1000000);
	# XXX: mode

	# sleep the scan time length
	usleep($opts{'u'} * 1000000);

	# test for the new level
	my $newchan = $rig->get_level_i($Hamlib::RIG_LEVEL_STRENGTH);;

	Verbose(sprintf("  checked %-12s (pri=%-4d at %-8.8s):  %d\n", $next, $config{$next}{'priority'}, $frequency, $newchan));

	# XXX: minimum timeout for falling back somehow?

	# if the new level is better, we'll use it (because the
	# priority is already higher).
	if ($newchan > $opts{'l'}) {
	    # use the current frequency of the new channel
	    # remember this one as the new "best"
	    $currentchannel = $next;
	    $currentstart = $time;
	    Verbose("current: $currentchannel\n");

	    # set the potentially needed tone/dcs code
	    $rig->set_ctcss_tone($config{$next}{'tone'} * 10)
	      if ($config{$next}{'tone'});
	    $rig->set_dcs_code($config{$next}{'dcs'} * 10)
	      if ($config{$next}{'dcs'})
	  } elsif ($currentchannel) {
	      # fall back to the previous lower priority channel

	      $rig->set_freq($config{$currentchannel}{'frequency'} * 1000000);
	  }


	# remember the last time we checked this new channel
	$config{$next}{'lastchecked'} = time();
    }
}

sub read_config {
    my ($file, $defaults) = @_;
    my $fh = new IO::File;
    $fh->open("<$file");
    my $line = 0;
    my %defaults = ();
    %defaults = %$defaults if ($defaults);
    while (<$fh>) {
	chomp();
	$line++;
	next if (/^\s*#/);
	next if (/^\s*$/);

	if (/^\s*default:\s*(.*)/) {
	    foreach my $data (split(/,\s*/,$1)) {
		my ($left, $right) = split(/\s*=\s*/, $data);
		$defaults{$left} = $right;
	    }
	} elsif (/^\s*include\s+(.*)/) {
	    read_config($1, \%defaults);
	} elsif (/^\s*group\s+([^:]+):\s*(.*)/) {
	    my $groupname = $1;
	    my $groups = $2;
	    push @{$groups{uc($groupname)}}, split(/,\s*/, uc($groups));
	} elsif (/^\s*(\w+)\s*:\s*([^,]*),*(.*)/) {
	    my $parts;
	    my $name = uc($1);
	    if (exists($config{$name})) {
		$parts = $config{$name};
	    } else {
		%$parts = %defaults;
		$config{$name} = $parts;
	    }
	    $parts->{'frequency'} = $2 if ($2);
	    foreach my $data (split(/,\s*/,$3)) {
		my ($left, $right) = split(/\s*=\s*/, $data);
		$parts->{$left} = $right;
	    }

	    if ($parts->{'frequency'} =~ /(.*)-(.*)/) {
		$parts->{'startfrequency'} = $1;
		$parts->{'endfrequency'} = $2;
	    }
	} else {
	    Error("Error in config file on line $line");
	}
    }
    $fh->close();
}

sub Error {
    print STDERR @_,"\n";
}

sub Verbose {
    print STDERR @_ if ($opts{'v'});
}

=cut

=head1 NAME

cq - scan a set of channels or frequencies

=head1 SYNOPSIS

cq operates in two modes: scanning channels for traffic or scanning
for generating a histogram.

=head1 USAGE

  cq -scan repeatername1,repeatername2,simplexname1,...

=head1 CONFIG FILE

$HOME/.cqrc can contain the following definition lines:

=head2 INCLUDE

To include another file, use:

  include /path/to/file

=head2 CHANNEL LINES

Lines that define channels look like:

  repeatername: 147.000,checkevery=5,priority=10

Which specifies the frequency to check, how often to check it and it's
priority level.

=head3 Range lines

Ranges are also allowed:

  20mSSB: 14.150-14.350,interval=.01

=head3 Channel and Range Tokens

=over

=item checkevery

How often (in seconds) to check the channel for traffic.

=item priority

Higher numbered priorities will be considered more important; lower
number priorities will not be searched at all until the higher number
priorities are completely silent.

(useful tip: set your local faviorite radio station (e.g. NPR) to
priority 1 and everything else higher than that; it'll ensure you're
always listening to at least something while it's scanning around your
other defined channels).

=item interval

=item tone

The CTCS tone that the rig should be set to when the channel is locked
onto (e.g. "123.0").

=item dcs

(only used for ranges)

=item enabled

Generally this isn't needed, but if set to I<false> it won't be used.

=item hangtime

The amount of time the channel should stay locked to after it goes silent.

=back

=head1 DESCRIPTION



=cut

