#!/usr/bin/perl

use Hamlib;
use Getopt::GUI::Long;
use strict;
use Time::HiRes qw(usleep gettimeofday tv_interval);
use Data::Dumper;

my %opts = (
	    P => '/dev/ttyS0',
	    M => '122',
	    S => '38400',

	    s => '14.150',
	    e => '14.350',
	    i => '.0001',
	    u => '.1',
	    samples => '1',
	    c => ($ENV{'HOME'} . "/.cqrc"),
	    l => -12,

	    time => 10,
	   );

Getopt::GUI::Long::Configure(qw(display_help no_ignore_case capture_output));
GetOptions(\%opts,
	   ["GUI:separator",     "Scanning Options:"],
	   ["s|start-frequency=s", "Starting Frequency"],
	   ["e|end-frequency=s",   "Ending Frequency"],
	   ["i|sample-interval=s", "Steps between frequencies"],
	   ["samples=s",           "Samples to take"],
	   ["l|minimum-level=s",   "Minimum signal level to be reported"],

	   ["state=s",             "store state in file"],
           ["load=s",              "load state from file; don't rescan"],

	   ["scan=s",              "Scan this definition set"],
	   ["u|usleep=s",          "time between sleeps"],

	   ["GUI:separator",   "Hamlib Controls:"],
	   ["P|port=s",        "Port to use (/dev/ttyS0)"],
	   ["M|model=s",         "Rig model (122)"],
	   ["S|speed=s",       "serial speed"],

	   ["GUI:separator",   "Setup options:"],
	   ["c|config",        "Config file to load"],
	   ["test",            "Test retunning speed of the receiver"],
	   ["test-freqs=s",    "Set the starting and various frequencies to jump to"],
	   ["v|verbose",       "Verbose mode"],

	   ["GUI:separator",   "Output Controls:"],
	   ["g|gnuplot=s",     "gnuplot data file"],
	   ["G|graphic=s",     "png data output"],
	   ["w",                "create an output window"],

	   ["nogui", "Don't show the gui"],
	  ) || die "bad arguments";

$| = 1;

Hamlib::rig_set_debug(1);
my $rig = new Hamlib::Rig($opts{'M'});
$rig->set_conf("rig_pathname", $opts{'P'});
$rig->set_conf("serial_speed",$opts{'S'});
$rig->open();
my $freq = $rig->get_freq();
my %data;

my %config;

#$rig->set_mode($Hamlib::RIG_MODE_USB, $Hamlib::RIG_PASSBAND_NORMAL);
#$rig->set_freq($opts{'s'} * 1000000);

read_config($opts{'c'});

if ($opts{'test'}) {
    my $startfreq = 14.250;
    my @jumpvalues = qw(.001 .00001 .25);
    if ($opts{'test-freqs'}) {
	($startfreq, @jumpvalues) = split(/,/,$opts{'test-freqs'});
    }

    $rig->set_freq($startfreq * 1000000);
    sleep(1);

    my $max = 0;
    foreach my $delta (@jumpvalues) {
	my $value = 0;
	Verbose("setting to $startfreq\n");
	$rig->set_freq($startfreq * 1000000);
	$value = $rig->get_level_i($Hamlib::RIG_LEVEL_STRENGTH);
	Verbose("  immediate value: $value\n");
	usleep(.5 * 1000000);
	$value = $rig->get_level_i($Hamlib::RIG_LEVEL_STRENGTH);
	Verbose("  initial value: $value\n");
	$value = 0;
	Verbose("  setting to " . ($startfreq+$delta) . "\n");
	$rig->set_freq(($startfreq+$delta) * 1000000);
	my $count = 0;
	$value = -54;
	my $prevvalue;
	my $startedat = [gettimeofday];
	while ($value < -32) {  # kinda arbitrary
	    $prevvalue = $value;
	    $value = $rig->get_level_i($Hamlib::RIG_LEVEL_STRENGTH);
	    $count++;
	    usleep(.00005 * 1000000);
	}
	Verbose("  final value: $value (was $value; $count polls to change)\n");
	my $diff = tv_interval($startedat, [gettimeofday]);
	Verbose("  $delta change => $diff\n");
	$max = ($max > $diff) ? $max : $diff;
    }
    printf("\nRecommended -u setting: %f (which is 5 * $max)\n",$max*5);

    exit;
}

#
# Load previous state
#
if ($opts{'load'}) {
    my $var = do "$opts{'load'}";
    %data = %$var;

#
# Scanning
#
} elsif ($opts{'scan'}) {
    my $currentchannel;

    my @toscan = keys(%config);
    if ($opts{'scan'} ne 1) {
	@toscan = split(/,\s*/,uc($opts{'scan'}));
    }

    while (1) {

	# see if current is active
	my $currentlevel;
	$currentlevel = $rig->get_level_i($Hamlib::RIG_LEVEL_STRENGTH)
	  if ($currentchannel);
	
	# decide what to search next
	my $time = time();
	my $next = "";

	# find the next channel to look for.
	foreach my $key (@toscan) {

	    # if it has been long enough based on config, check it
	    if ($config{$key}{'lastchecked'} < $time + ($config{$key}{'checkevery'} || $opts{'time'})) {

		# if disabled, forget it
		next if ($config{$key}{'enabled'} eq 'false');

		# if the current channel is active and is a higher
		# priority, then skip this one.
		next if ($currentchannel &&
			 $currentlevel > $opts{'l'} && 
			 $config{$key}{'priority'} <=
			 $config{$currentchannel}{'priority'});

		# if we've checked it recently enough, don't do again
		next if ($config{$key}{'lastchecked'} +
			 ($config{$next}{'checkevery'} || $opts{'time'}) >
			 $time);

		# ok, then we should definitely search it.  But we
		# need to pick the best one, so see if we have another
		# one that needs to be checked first.
		# XXX: optionally use priorities instead of time for sorting?
		if (!$next) {
		    $next = $key;
		} elsif ($config{$next}{'lastchecked'}
			 + ($config{$next}{'checkevery'} || $opts{'time'}) >
			 $config{$key}{'lastchecked'}
			 + ($config{$key}{'checkevery'} || $opts{'time'})) {
		    $next = $key;
		}
	    }
	}

	# now that we've found one to check...
	if ($next) {
	    my $frequency;

	    # normal channel or frequency range?
	    if ($config{$next}{'endfrequency'}) {
		# we're scanning a whole range; take the next step forward
		if ($config{$next}{'currentfrequency'}) {
		    $frequency = $config{$next}{'currentfrequency'} +
		      $config{$next}{'interval'} || $opts{'i'};
		    if ($frequency > $config{$next}{'endfrequency'}) {
			$frequency = $config{$next}{'startfrequency'};
		    }
		} else {
		    $frequency = $config{$next}{'startfrequency'};
		}
		$config{$next}{'currentfrequency'} = $frequency;
	    } else {
		# just a single channel
		$frequency = $config{$next}{'frequency'};
	    }

	    # what to check next?
	    Verbose(sprintf("  checking %-12s (pri=%-4d at $frequency)\n", $next, $config{$next}{'priority'}));

	    # change the frequency and potentially the mode
	    $rig->set_freq($frequency * 1000000);
	    # XXX: mode

	    # sleep the scan time length
	    usleep($opts{'u'} * 1000000);

	    # test for the new level
	    my $newchan = $rig->get_level_i($Hamlib::RIG_LEVEL_STRENGTH);;

	    # XXX: minimum timeout for falling back somehow?

	    # if the new level is better, we'll use it (because the
	    # priority is already higher).
	    if ($newchan > $opts{'l'}) {
		# use the current frequency of the new channel
		# remember this one as the new "best"
		$currentchannel = $next;
		Verbose("current: $currentchannel\n");

		# set the potentially needed tone/dcs code
		$rig->set_ctcss_tone($config{$next}{'tone'} * 10)
		  if ($config{$next}{'tone'});
		$rig->set_dcs_code($config{$next}{'dcs'} * 10)
		  if ($config{$next}{'dcs'})
	    } else {
		# fall back to the previous lower priority channel

		$rig->set_freq($config{$currentchannel}{'frequency'} * 1000000);
	    }


	    # remember the last time we checked this new channel
	    $config{$next}{'lastchecked'} = time();
	}

	# XXX: configurable sleep needed.
	sleep(1);
    }
} else {
    for (my $freq = $opts{'s'}; $freq <= $opts{'e'}; $freq += $opts{'i'}) {
	$rig->set_freq($freq * 1000000);

	my $value;
	my $count = 0;
	while ($count < $opts{'samples'}) {
	    usleep($opts{'u'} * 1000000);
	    $value += $rig->get_level_i($Hamlib::RIG_LEVEL_STRENGTH);
	    $count++;
	}
	$data{$freq} = $value / $count;
    }
}

    if ($opts{'state'}) {
	open(O,">$opts{'state'}");
	print O Dumper(\%data);
	close(O);
    }

my @keys = sort keys(%data);
my @sortedbylevel = sort { $data{$b} <=> $data{$a} } @keys;
my $leveltobeat = $opts{'l'} || $data{$sortedbylevel[int($#sortedbylevel/2)]};

my $ingood = 0;
my $startgood = 0;
my $level;
Verbose("finding signals above:  $leveltobeat\n");
for (my $i = 0; $i < $#keys; $i++) {
    if (!$ingood && $data{$keys[$i]} > $leveltobeat) {
	# starting a signal
	$ingood = 1;
	Verbose("good starting at: $keys[$i]\n");
	$startgood = $keys[$i];
	$level = $data{$keys[$i]};
    } elsif ($ingood && $data{$keys[$i]} <= $leveltobeat) {
	# falling out
	$ingood = 0;
	Verbose("	    end: $keys[$i]\n");
	printf ("	   diff: %-4.4f\n", ($keys[$i] - $startgood));
        Verbose("   level: $level\n");
	Verbose("	 center: " . ($startgood + ($keys[$i] - $startgood)/2) . "\n");
    } elsif ($ingood) {
	$level = $data{$keys[$i]} if ($level < $data{$keys[$i]});
    }
}

if ($opts{'g'}) {
    open(G, ">$opts{'g'}");
    foreach my $key (@keys) {
	print G "$key  $data{$key}\n";
    }
    close(G);
}

if ($opts{'G'}) {
    my $im = create_freq_graph();
    open(G,">$opts{'G'}");
    binmode G;
    print G $im->png;
}

if ($opts{'w'}) {
    my $im = create_freq_graph();
    open(G,">/tmp/cq.png");
    binmode G;
    print G $im->png;
    close(G);
}

sub create_freq_graph {
    use GD;
    my $height = 100;
    my $im = new GD::Image($#keys,$height);
    my $fill = $im->colorAllocate(0,0,255);
    my $white = $im->colorAllocate(255,255,255);
    $im->fill(1,1,$white);

    my $count = 0;
    foreach my $key (@keys) {
	$im->rectangle($count, $height - ($data{$key} + 50), $count+1, $height, $fill);
	$count++;
    }
    return $im;
}

#
# Wx widget support
#
package MyApp;

use Wx qw(:everything);
use Wx::Event qw(EVT_MENU);
use Wx::App;
our @ISA=qw(Wx::App);

sub OnInit {
   my $this = @_;
   my $frame = MyFrame->new( "Spectrum Plot", [-1,-1], [-1,-1]);
   #my $this->{FRAME}=$frame;
   unless ($frame) {
       print "unable to create frame -- exiting."; 
       return undef;
   }
   $frame->Show( 1 );
   1;
}

package MyFrame;
use vars qw(@ISA);
use strict;
#
#   All we load here are constants used
#   to keep the image stretched to the dimensions of the window.
#
use Wx qw(wxWidth wxHeight wxLeft wxTop wxDefaultPosition wxDefaultSize wxID_CANCEL wxCentreX wxCentreY);
use Wx::Event qw(:everything);
#
#   Wx::Image loads the Image control and all of the Image handlers.
#
use IO::File;
use Wx::Event ;
our @ISA=qw(Wx::Frame);


sub new {
   my $class = shift;
   my $this = $class->SUPER::new( undef, -1, $_[0], $_[1], $_[2] );
   #
   #   replace the filename with something appropriate.
   #
   my $file = IO::File->new( "/tmp/cq.png", "r" );
   unless ($file) {print "Can't load saved png.";return undef};
   binmode $file;
   my $handler = Wx::PNGHandler->new();
   my $image = Wx::Image->new();
   my $bmp;    # used to hold the bitmap.
   $handler->LoadFile( $image, $file );
   $bmp = Wx::Bitmap->new($image); 

   if( $bmp->Ok() ) {
      #  create a static bitmap called ImageViewer that displays the
      #  selected image.
      $this->{ImageViewer}= Wx::StaticBitmap->new($this, -1, $bmp);
   }
   $this->{ScaleImage}=0;

   $this->SetAutoLayout( 1 );  # allow wxperl to manage control sizing & placement
   # Layout constraints provide the guides
   # for wxperl's autolayout.
   my $b1 = Wx::LayoutConstraints->new();
   my $b2 = Wx::LayoutConstraints->new();

   # These constrainst define the placement and
   # dimensions of the controls they're bound to,
   # and can be either absolute, or relative to
   # other controls
   $b1->left->Absolute(0);
   $b1->top->Absolute(0);
   $b1->width->PercentOf( $this, wxWidth,50);
   $b1->height->PercentOf( $this, wxHeight, 100);
   $this->{ImageViewer}->SetConstraints($b1);

   #
   # Set up the menu bar.
   #
   my $file_menu = Wx::Menu->new();
   my ($OPEN_NEW_DIR, $REMOVE_DIR, $SCALE_IMAGE, $APP_QUIT)=(1..100);
   $file_menu->Append( $OPEN_NEW_DIR, "&Open A Directory\tCtrl-O");
   $file_menu->AppendSeparator();
   $file_menu->Append($SCALE_IMAGE,"&Scale Images To Window\tCtrl-S","",1);
   $file_menu->AppendSeparator();
   $file_menu->Append ($APP_QUIT, "E&xit\tCtrl-x","Exit Application");
   #
   # Note that even though there are 6 options, only
   # 4 of them are active as they're the only ones
   # bound to event handlers.
   #
#   EVT_MENU($this, $OPEN_NEW_DIR, \&OnDirDialog);
#   EVT_MENU($this, $SCALE_IMAGE,  \&Set_Scale);
   EVT_MENU($this, $APP_QUIT,     sub {$_[0]->Close( 1 )});

   my $menubar= Wx::MenuBar->new();
   $menubar->Append ($file_menu, "&File");
   $this->SetMenuBar($menubar);

   $this;  # return the frame object to the calling application.
}


package main;

if ($opts{'w'}) {
    my $app = MyApp->new();	# create
    $app->MainLoop();		# go
}

sub read_config {
    my ($file) = @_;
    open(C, "<$file");
    my $line = 0;
    my %defaults = ();
    while (<C>) {
	chomp();
	$line++;
	next if (/^\s*#/);
	next if (/^\s*$/);

	if (/^\s*default:\s*(.*)/) {
	    foreach my $data (split(/,\s*/,$1)) {
		my ($left, $right) = split(/\s*=\s*/, $data);
		$defaults{$left} = $right;
	    }
	} elsif (/^\s*(\w+):\s*([^,]+),*(.*)/) {
	    my $parts;
	    %$parts = %defaults;
	    my $name = uc($1);
	    $config{$name} = $parts;
	    $parts->{'frequency'} = $2;
	    foreach my $data (split(/,\s*/,$3)) {
		my ($left, $right) = split(/\s*=\s*/, $data);
		$parts->{$left} = $right;
	    }

	    if ($parts->{'frequency'} =~ /(.*)-(.*)/) {
		$parts->{'startfrequency'} = $1;
		$parts->{'endfrequency'} = $2;
	    }
	} else {
	    Error("Error in config file on line $line");
	}
    }
}

sub Error {
    print STDERR @_,"\n";
}

sub Verbose {
    print STDERR @_ if ($opts{'v'});
}

=cut

=head1 NAME

cq - scan a set of channels or frequencies

=head1 SYNOPSIS

cq operates in two modes: scanning channels for traffic or scanning
for generating a histogram.

=head1 USAGE

  cq -scan repeatername1,repeatername2,simplexname1,...

=head1 CONFIG FILE

$HOME/.cqrc can contain the following definition lines:

=head2 CHANNEL LINES

Lines that define channels look like:

  repeatername: 147.000,checkevery=5,priority=10

Which specifies the frequency to check, how often to check it and it's
priority level.

=head3 Range lines

Ranges are also allowed:

  20mSSB: 14.150-14.350,interval=.01

=head3 Tokens

=over

=item checkevery

=item priority

=item interval

=item tone

=item dcs

(only used for ranges)

=item enabled

Generally this isn't needed, but if set to I<false> it won't be used.

=back

=head1 DESCRIPTION



=cut

